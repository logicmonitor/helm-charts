{
  "$schema": "http://json-schema.org/draft-07/schema",
  "$id": "https://example.com/example.json",
  "type": "object",
  "title": "Argus Helm Chart Configuration Schema",
  "description": "The Argus Helm Chart Configuration Schema",
  "default": {},
  "examples": [
    {
      "accessID": "",
      "accessKey": "",
      "account": "",
      "clusterName": "",
      "clusterTreeParentID": 1,
      "enableLegacyResourceTree": false,
      "image": {
        "repository": "logicmonitor/argus",
        "pullPolicy": "",
        "tag": ""
      },
      "nodeSelector": {},
      "affinity": {},
      "priorityClassName": "",
      "tolerations": [],
      "resources": {},
      "labels": {},
      "annotations": {},
      "replicas": 1,
      "resourceContainerID": 1,
      "log": {
        "level": "info"
      },
      "collectorsetcontroller": {
        "address": "collectorset-controller",
        "port": 50000
      },
      "proxy": {
        "url": "",
        "user": "",
        "pass": ""
      },
      "etcdDiscoveryToken": "",
      "ignoreSSL": false,
      "daemons": {
        "lmResourceSweeper": {
          "interval": "PT10M"
        },
        "lmCacheSync": {
          "interval": "PT1H"
        },
        "worker": {
          "poolSize": 10
        },
        "watcher": {
          "bulkSyncInterval": "PT30M",
          "runner": {
            "poolSize": 10,
            "backPressureQueueSizePerRunner": 10
          },
          "sysIpsWaitTimeout": "PT5M"
        }
      },
      "monitoring": {
        "disable": []
      },
      "lm": {
        "lmlogs": {
          "k8sevent": {
            "enable": false
          },
          "k8spodlog": {
            "enable": false
          }
        },
        "resource": {
          "globalDeleteAfterDuration": "P0DT0H0M0S",
          "alerting": {
            "disable": []
          }
        },
        "resourceGroup": {
          "extraProps": {
            "cluster": [],
            "nodes": [],
            "etcd": []
          }
        }
      },
      "filters": [],
      "selfMonitor": {
        "enable": false,
        "port": 2112
      },
      "debug": {
        "profiling": {
          "enable": false
        }
      },
      "collector": {
        "replicas": 1,
        "version": 0,
        "size": "small",
        "useEA": false,
        "lm": {
          "groupID": 0,
          "escalationChainID": 0
        },
        "image": {
          "repository": "logicmonitor/collector",
          "tag": "latest",
          "pullPolicy": ""
        },
        "proxy": {
          "url": "",
          "user": "",
          "pass": ""
        },
        "annotations": {},
        "labels": {},
        "statefulsetSpec": {
          "template": {
            "spec": {
              "nodeSelector": {},
              "tolerations": [],
              "priorityClassName": ""
            }
          }
        }
      },
      "global": {
        "accessID": "",
        "accessKey": "",
        "account": "",
        "proxy": {
          "url": "",
          "user": "",
          "pass": ""
        },
        "image": {
          "pullPolicy": "Always"
        },
        "collectorsetServiceNameSuffix": "",
        "userDefinedSecret": ""
      },
      "nameOverride": "",
      "fullnameOverride": "",
      "rbac": {
        "create": true
      },
      "serviceAccount": {
        "create": true
      }
    }
  ],
  "required": [
    "accessID",
    "accessKey",
    "account",
    "clusterName",
    "clusterTreeParentID"
  ],
  "properties": {
    "enabled": {
      "$id": "#/properties/enabled",
      "description": "Defined for umbrella chart but unused here.",
      "type": "boolean",
      "default": true,
      "$comment": "tf:optional"
    },
    "accessID": {
      "$id": "#/properties/accessID",
      "type": "string",
      "title": "Logicmonitor API Token accessID",
      "description": "The LogicMonitor API key ID.\nNOTE: Ensure to add surrounding double quotes to avoid special character parsing errors.",
      "default": "",
      "examples": [
        ""
      ],
      "$comment": "ui:accessId-ignore tf:optional"
    },
    "accessKey": {
      "$id": "#/properties/accessKey",
      "type": "string",
      "title": "Logicmonitor API Token accessKey",
      "description": "The LogicMonitor API key.\nNOTE: Ensure to add surrounding double quotes to avoid special character parsing errors.",
      "default": "",
      "examples": [
        ""
      ],
      "$comment": "ui:accessKey-ignore tf:optional"
    },
    "account": {
      "$id": "#/properties/account",
      "type": "string",
      "title": "Logicmonitor account name",
      "description": "The LogicMonitor account name.nValue should be trimmed from URL \"___.logicmonitor.com\"\nexample: lmqauat.logicmonitor.com then \"lmqauat\" must be a valid value.",
      "default": "",
      "examples": [
        "lmqauat"
      ],
      "$comment": "ui:account-ignore tf:optional"
    },
    "clusterName": {
      "$id": "#/properties/clusterName",
      "type": "string",
      "title": "Friendly Cluster Name",
      "description": "The unique name to give to the cluster's resource group.\nNOTE: You must not change the name once the application is deployed in the cluster. If changed, breaks correlation at multiple places\nexample: Organised Resource group name of Kubernetes resource tree, is generated as \"Kubernetes Cluster: <clusterName>\"",
      "default": "",
      "examples": [
        ""
      ],
      "$comment": "ui:clusterName tf:"
    },
    "clusterTreeParentID": {
      "$id": "#/properties/clusterTreeParentID",
      "type": "integer",
      "title": "The clusterTreeParentID",
      "description": "clusterTreeParentID is a parent static resource group ID under which the organised Kubernetes resource tree gets created.\nA static resource group with the mentioned ID should exit beforehand.",
      "default": 1,
      "minimum": 1,
      "examples": [
        1
      ],
      "$comment": "ui:clusterGroupID tf:optional"
    },
    "enableLegacyResourceTree" : {
      "$comment": "tf:optional",
      "$id": "#/properties/enableLegacyResourceTree",
      "type": "boolean",
      "title": "The enableLegacyResourceTree param",
      "description": "Set flag to enable legacy resource tree structure.",
      "default": false,
      "examples": [
        false
      ]
    },
    "image": {
      "$id": "#/properties/image",
      "type": "object",
      "title": "Argus Docker Image Schema",
      "description": "The image contains the Argus docker image details.",
      "default": {},
      "examples": [
        {
          "registry": "382028353997.dkr.ecr.us-west-2.amazonaws.com",
          "repository": "logicmonitor/argus",
          "pullPolicy": "Always",
          "tag": "v6"
        }
      ],
      "required": [],
      "$comment": "tf:optional",
      "properties": {
        "registry": {
          "$id": "#/properties/image/properties/registry",
          "$comment": "tf:optional",
          "type": "string",
          "title": "Argus Image Registry Schema",
          "description": "The Docker Registry from which Argus image is pulled.\ndefaults to empty value.",
          "default": "",
          "minLength": 0,
          "examples": [
            "382028353997.dkr.ecr.us-west-2.amazonaws.com"
          ]
        },
        "repository": {
          "$id": "#/properties/image/properties/repository",
          "$comment": "tf:optional",
          "type": "string",
          "title": "Argus Image Repository Schema",
          "description": "The Docker Repository Name for Argus Image",
          "default": "logicmonitor",
          "minLength": 0,
          "examples": [
            "logicmonitor"
          ]
        },
        "name": {
          "$id": "#/properties/image/properties/name",
          "$comment": "tf:optional",
          "type": "string",
          "title": "Argus Image Name Schema",
          "description": "The Docker Argus Image Name",
          "default": "argus",
          "minLength": 1,
          "examples": [
            "argus"
          ]
        },
        "pullPolicy": {
          "$id": "#/properties/image/properties/pullPolicy",
          "$comment": "tf:optional",
          "type": "string",
          "title": "The Argus pullPolicy Schema",
          "description": "Overrides the image pullPolicy.\nDefaults to \"Always\".",
          "default": "Always",
          "enum": [
            "Always",
            "IfNotPresent",
            "Never",
            ""
          ],
          "examples": [
            "Always"
          ]
        },
        "tag": {
          "$id": "#/properties/image/properties/tag",
          "$comment": "tf:optional",
          "type": "string",
          "title": "The Argus Image tag schema",
          "description": "The Argus Docker Image Tag.\nOverrides the image tag whose default is the chart appVersion.",
          "default": "",
          "examples": [
            ""
          ]
        }
      },
      "additionalProperties": false
    },
    "nodeSelector": {
      "$id": "#/properties/nodeSelector",
      "$comment": "tf:optional,yamlencode",
      "type": "object",
      "title": "nodeSelector",
      "description": "NodeSelector is a selector, which must be set to true for the pod to fit on a node. The selector must match the node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
      "default": {},
      "examples": [
        {}
      ],
      "required": [],
      "additionalProperties": {
        "type": "string"
      }
    },
    "affinity": {
      "$id": "#/properties/affinity",
      "type": "object",
      "$comment": "tf:optional,yamlencode",
      "title": "affinity",
      "description": "Affinity allows you to constrain which nodes your pod is eligible to be scheduled on.",
      "default": {},
      "examples": [
        {}
      ],
      "required": []
    },
    "priorityClassName": {
      "$id": "#/properties/priorityClassName",
      "type": "string",
      "$comment": "tf:optional",
      "title": "priorityClassName",
      "description": "The priority class name for Pod priority. If the priorityClassName parameter is enabled, then PriorityClass resource is created, or the Pod is rejected.",
      "default": "",
      "examples": [
        ""
      ]
    },
    "tolerations": {
      "$id": "#/properties/tolerations",
      "type": "array",
      "$comment": "tf:optional,yamlencode",
      "title": "tolerations",
      "description": "tolerations are applied to pods, and allow the pods to schedule onto nodes with matching taints.",
      "default": [],
      "examples": [
        []
      ],
      "additionalItems": true,
      "items": {
        "$id": "#/properties/tolerations/items",
        "$ref": "#/definitions/toleration"
      },
      "uniqueItems": true
    },
    "resources": {
      "$id": "#/properties/resources",
      "type": "object",
      "$comment": "tf:optional",
      "title": "The Argus resource limits schema",
      "description": "The Argus pod resource limits",
      "default": {},
      "examples": [
        {
          "limits": {
            "cpu": "1000m",
            "memory": "1Gi",
            "ephemeral-storage": "100Mi"
          },
          "requests": {
            "cpu": "1000m",
            "memory": "1Gi",
            "ephemeral-storage": "100Mi"
          }
        }
      ],
      "properties": {
        "limits": {
          "$id": "#/properties/resources/properties/limits",
          "$comment": "tf:optional,yamlencode",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          },
          "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
          "type": "object"
        },
        "requests": {
          "$id": "#/properties/resources/properties/requests",
          "$comment": "tf:optional,yamlencode",
          "additionalProperties": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.api.resource.Quantity"
          },
          "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
          "type": "object"
        }
      },
      "additionalProperties": false,
      "required": []
    },
    "labels": {
      "$id": "#/properties/labels",
      "type": "object",
      "$comment": "tf:optional,yamlencode",
      "title": "The Argus extra labels schema",
      "description": "Labels to apply on all objects created by Argus. Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/user-guide/labels",
      "default": {},
      "examples": [
        {}
      ],
      "required": [],
      "additionalProperties": {
        "type": "string"
      }
    },
    "annotations": {
      "$id": "#/properties/annotations",
      "type": "object",
      "title": "The Argus extra annotations schema",
      "description": "Annotations to apply on all objects created by Argus. Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/user-guide/annotations",
      "default": {},
      "examples": [
        {}
      ],
      "required": [],
      "additionalProperties": {
        "type": "string"
      },
      "$comment": "tf:optional,yamlencode"
    },
    "replicas": {
      "$id": "#/properties/replicas",
      "type": "integer",
      "title": "The replicas schema",
      "description": "Argus Pod Replicas - defaults to 1, parameter is just for development purpose, do not increase more than one replicas in production",
      "default": 1,
      "minimum": 0,
      "maximum": 1,
      "examples": [
        1
      ]
    },
    "resourceContainerID": {
      "$id": "#/properties/resourceContainerID",
      "type": "integer",
      "title": "The resourceContainerID schema",
      "description": "You must use the resourceContainerID when you install Argus as a non-admin user. \nThe resourceContainerID is a parent resource group id that holds all cluster resources under it.",
      "default": 1,
      "minimum": 1,
      "examples": [
        1
      ],
      "$comment": "ui:resourceGroupID tf:optional"
    },
    "log": {
      "$id": "#/properties/log",
      "$comment": "tf:optional",
      "type": "object",
      "title": "Log",
      "description": "The Argus Log Configurations Schema",
      "default": {},
      "examples": [
        {
          "level": "info"
        }
      ],
      "required": [
      ],
      "properties": {
        "level": {
          "$id": "#/properties/log/properties/level",
          "$comment": "tf:optional",
          "type": "string",
          "title": "The Log Level for Argus Schema",
          "description": "The Log Level for Argus",
          "default": "info",
          "enum": [
            "info",
            "warn",
            "warning",
            "debug",
            "trace",
            "error",
            "fatal",
            "panic"
          ],
          "examples": [
            "info"
          ]
        }
      },
      "additionalProperties": false
    },
    "collectorsetcontroller": {
      "$comment": "tf:optional",
      "$id": "#/properties/collectorsetcontroller",
      "type": "object",
      "title": "The collectorsetcontroller schema",
      "description": "The Collectorset-Controller Configurations",
      "default": {},
      "examples": [
        {
          "address": "collectorset-controller",
          "port": 50000
        }
      ],
      "required": [
      ],
      "properties": {
        "address": {
          "$comment": "tf:optional",
          "$id": "#/properties/collectorsetcontroller/properties/address",
          "type": "string",
          "title": "The CollectorsetController Address Schema",
          "description": "The Collectorset-controller grpc service address",
          "default": "collectorset-controller",
          "minLength": 1,
          "examples": [
            "collectorset-controller"
          ]
        },
        "port": {
          "$comment": "tf:optional",
          "$id": "#/properties/collectorsetcontroller/properties/port",
          "type": "integer",
          "title": "port",
          "description": "The Collectorset-controller grpc service port",
          "minimum": 2,
          "default": 50000,
          "examples": [
            50000
          ]
        }
      },
      "additionalProperties": false
    },
    "proxy": {
      "$id": "#/properties/proxy",
      "$comment": "tf:optional",
      "type": "object",
      "title": "The proxy schema",
      "description": "The Http/s proxy for Argus",
      "default": {},
      "examples": [
        {
          "url": "",
          "user": "",
          "pass": ""
        }
      ],
      "required": [
      ],
      "properties": {
        "url": {
          "$id": "#/properties/proxy/properties/url",
          "type": "string",
          "title": "The Proxy Server URL Schema",
          "description": "The Proxy Server's URL",
          "default": "",
          "examples": [
            ""
          ],
          "$comment": "ui:proxyURL-ignore tf:optional"
        },
        "user": {
          "$id": "#/properties/proxy/properties/user",
          "type": "string",
          "title": "The Proxy Server's User schema",
          "description": "User for the Proxy Server.",
          "default": "",
          "examples": [
            ""
          ],
          "$comment": "ui:proxyUser-ignore tf:optional"
        },
        "pass": {
          "$id": "#/properties/proxy/properties/pass",
          "type": "string",
          "title": "The Proxy Server's Password schema",
          "description": "Password for the Proxy Server",
          "default": "",
          "examples": [
            ""
          ],
          "$comment": "ui:proxyPass-ignore tf:optional"
        }
      },
      "additionalProperties": false
    },
    "etcdDiscoveryToken": {
      "$comment": "tf:optional",
      "$id": "#/properties/etcdDiscoveryToken",
      "type": "string",
      "title": "The ETCD DiscoveryToken Schema",
      "description": "The ETCD DiscoveryToken.",
      "default": "",
      "examples": [
        ""
      ],
      "$comment": "ui:etcdDiscoveryToken"
    },
    "ignoreSSL": {
      "$comment": "tf:optional",
      "$id": "#/properties/ignoreSSL",
      "type": "boolean",
      "title": "The ignoreSSL Schema",
      "description": "Set flag to ignore ssl/tls validation.",
      "default": false,
      "examples": [
        false
      ]
    },
    "daemons": {
      "$comment": "tf:optional",
      "$id": "#/properties/daemons",
      "type": "object",
      "title": "The Argus Daemon configurations Schema",
      "description": "The Argus Daemon configurations.",
      "default": {},
      "examples": [
        {
          "lmResourceSweeper": {
            "interval": "10m"
          },
          "lmCacheSync": {
            "interval": "1h"
          },
          "worker": {
            "poolSize": 10
          },
          "watcher": {
            "bulkSyncInterval": "30m",
            "runner": {
              "poolSize": 10,
              "backPressureQueueSizePerRunner": 10
            },
            "sysIpsWaitTimeout": "5m"
          }
        }
      ],
      "required": [
      ],
      "properties": {
        "lmResourceSweeper": {
          "$comment": "tf:optional",
          "$id": "#/properties/daemons/properties/lmResourceSweeper",
          "type": "object",
          "title": "The LM Resource sweeper configurations Schema",
          "description": "The LM Resource sweeper configurations.",
          "default": {},
          "examples": [
            {
              "interval": "10m"
            }
          ],
          "required": [
          ],
          "properties": {
            "interval": {
              "$comment": "tf:optional",
              "$id": "#/properties/daemons/properties/lmResourceSweeper/properties/interval",
              "type": "string",
              "title": "The LogicMonitor Resource sweeper Interval Schema",
              "description": "The LogicMonitor Resource sweeper Run Interval Duration.",
              "default": "10m",
              "examples": [
                "0h10m0s"
              ],
              "pattern": "^(\\d+h)?(\\d+m)?(\\d+s)?(\\d+[u]s)?(\\d+ns)?$"
            }
          },
          "additionalProperties": false
        },
        "lmCacheSync": {
          "$comment": "tf:optional",
          "$id": "#/properties/daemons/properties/lmCacheSync",
          "type": "object",
          "title": "The Cache Sync using LogicMonitor resources configurations Schema",
          "description": "The Cache Sync using LogicMonitor resources configurations.",
          "default": {},
          "examples": [
            {
              "interval": "1h"
            }
          ],
          "required": [
          ],
          "properties": {
            "interval": {
              "$comment": "tf:optional",
              "$id": "#/properties/daemons/properties/lmCacheSync/properties/interval",
              "type": "string",
              "title": "The Cache Sync using LogicMonitor resources Interval Schema",
              "description": "The Cache Sync using LogicMonitor resources Run Interval Duration.",
              "default": "1h",
              "examples": [
                "1h0m0s"
              ],
              "pattern": "^(\\d+h)?(\\d+m)?(\\d+s)?(\\d+[u]s)?(\\d+ns)?$"
            }
          },
          "additionalProperties": false
        },
        "worker": {
          "$comment": "tf:optional",
          "$id": "#/properties/daemons/properties/worker",
          "type": "object",
          "title": "The Worker configurations Schema",
          "description": "The Worker configurations.",
          "default": {},
          "examples": [
            {
              "poolSize": 10
            }
          ],
          "required": [
          ],
          "properties": {
            "poolSize": {
              "$comment": "tf:optional",
              "$id": "#/properties/daemons/properties/worker/properties/poolSize",
              "type": "integer",
              "title": "The Worker poolSize schema",
              "description": "The number of workers in a pool.",
              "default": 10,
              "minimum": 1,
              "examples": [
                10
              ]
            }
          },
          "additionalProperties": false
        },
        "watcher": {
          "$comment": "tf:optional",
          "$id": "#/properties/daemons/properties/watcher",
          "type": "object",
          "title": "The Kubernetes watcher configurations Schema",
          "description": "The Kubernetes watcher configurations.",
          "default": {},
          "examples": [
            {
              "bulkSyncInterval": "PT30M",
              "runner": {
                "poolSize": 10,
                "backPressureQueueSizePerRunner": 10
              },
              "sysIpsWaitTimeout": "PT5M"
            }
          ],
          "required": [
          ],
          "properties": {
            "bulkSyncInterval": {
              "$comment": "tf:optional",
              "$id": "#/properties/daemons/properties/watcher/properties/bulkSyncInterval",
              "type": "string",
              "title": "bulkSyncInterval",
              "description": "The Bulk Discovery Run Interval Duration.",
              "default": "30m",
              "examples": [
                "0h30m0s"
              ],
              "pattern": "^(\\d+h)?(\\d+m)?(\\d+s)?(\\d+[u]s)?(\\d+ns)?$"
            },
            "runner": {
              "$comment": "tf:optional",
              "$id": "#/properties/daemons/properties/watcher/properties/runner",
              "type": "object",
              "title": "The runner configurations schema",
              "description": "The configurations for parallel runners to process watcher events.",
              "default": {},
              "examples": [
                {
                  "poolSize": 10,
                  "backPressureQueueSizePerRunner": 10
                }
              ],
              "required": [
              ],
              "properties": {
                "poolSize": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/daemons/properties/watcher/properties/runner/properties/poolSize",
                  "type": "integer",
                  "title": "The Runner poolSize schema",
                  "description": "The number runners in a pool.",
                  "default": 10,
                  "minimum": 1,
                  "examples": [
                    10
                  ]
                },
                "backPressureQueueSizePerRunner": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/daemons/properties/watcher/properties/runner/properties/backPressureQueueSizePerRunner",
                  "type": "integer",
                  "title": "The Number of events to queue per runner schema",
                  "description": "The number of events to queue per runner.",
                  "default": 10,
                  "minimum": 1,
                  "examples": [
                    10
                  ]
                }
              }
            },
            "sysIpsWaitTimeout": {
              "$id": "#/properties/daemons/properties/watcher/properties/sysIpsWaitTimeout",
              "$comment": "tf:optional",
              "type": "string",
              "title": "The sysIpsWaitTimeout schema",
              "description": "The sysIpsWaitTimeout is a timout for argus to wait till Logicmonitor portal copies system.hostname value into system.ips for updated IP of resource",
              "default": "5m",
              "examples": [
                "0h5m0s"
              ],
              "pattern": "^(\\d+h)?(\\d+m)?(\\d+s)?(\\d+[u]s)?(\\d+ns)?$"
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "monitoring": {
      "$comment": "tf:optional",
      "$id": "#/properties/monitoring",
      "type": "object",
      "title": "The monitoring schema",
      "description": "The Monitoring settings",
      "default": {},
      "examples": [
        {
          "disable": [],
          "annotations": []
        }
      ],
      "required": [
      ],
      "properties": {
        "disable": {
          "$comment": "tf:optional,yamlencode",
          "$id": "#/properties/monitoring/properties/disable",
          "type": "array",
          "title": "The disable schema",
          "description": "Set of resource names to disable monitoring for.",
          "default": [],
          "examples": [
            []
          ],
          "additionalItems": true,
          "items": {
            "$id": "#/properties/monitoring/properties/disable/items",
            "type": "string"
          },
          "uniqueItems": true
        },
        "annotations": {
          "$comment": "tf:optional,yamlencode",
          "id": "#/properties/monitoring/properties/annotations",
          "type": "object",
          "title": "Annotations settings",
          "description": "Annotation settings",
          "default": [],
          "examples": [
            {
              "ignore": []
            }
          ],
          "properties": {
            "ignore": {
              "$comment": "tf:optional,yamlencode",
              "id": "#/properties/monitoring/properties/annotations/ignore",
              "title": "Ignored Annotations",
              "description": "Annotations Rules to ignore them while update operation is being performed",
              "type": "array",
              "additionalItems": false,
              "items": {
                "$id": "#/properties/monitoring/properties/annotations/ignore/items",
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          "additionalItems": false,
          "items": true
        },
        "labels": {
          "$comment": "tf:optional,yamlencode",
          "id": "#/properties/monitoring/properties/labels",
          "type": "object",
          "title": "Labels settings",
          "description": "Label settings",
          "default": [],
          "examples": [
            {
              "ignore": []
            }
          ],
          "properties": {
            "ignore": {
              "$comment": "tf:optional,yamlencode",
              "id": "#/properties/monitoring/properties/labels/ignore",
              "title": "Ignored Labels for update events",
              "description": "Labels Rules to ignore them while update operation is being performed",
              "type": "array",
              "additionalItems": false,
              "items": {
                "$id": "#/properties/monitoring/properties/labels/ignore/items",
                "type": "string"
              },
              "uniqueItems": true
            }
          },
          "additionalItems": false,
          "items": true
        }
      },
      "additionalProperties": false
    },
    "lm": {
      "$id": "#/properties/lm",
      "$comment": "tf:optional",
      "type": "object",
      "title": "The Logicmonitor Portal Configurations",
      "description": "The settings or configurations which reflect on LogicMonitor portal.",
      "default": {},
      "examples": [
        {
          "opsNotes": {
            "secrets": {
              "helmCharts": {
                "enabled": false
              }
            }
          },
          "lmlogs": {
            "k8sevent": {
              "enable": false
            },
            "k8spodlog": {
              "enable": false
            }
          },
          "resource": {
            "globalDeleteAfterDuration": "P0DT0H0M0S",
            "alerting": {
              "disable": []
            }
          },
          "resourceGroup": {
            "extraProps": {
              "cluster": [],
              "nodes": [],
              "etcd": []
            }
          }
        }
      ],
      "required": [
      ],
      "properties": {
        "opsNotes": {
          "$comment": "tf:optional",
          "$id": "#/properties/lm/properties/opsNotes",
          "type": "object",
          "title": "The OpsNotes schema",
          "description": "The LogicMonitor OpsNotes settings.",
          "default": {},
          "examples": [
            {
              "secrets": {
                "helmCharts": {
                  "enabled": false
                }
              }
            }
          ],
          "required": [
          ],
          "properties": {
            "secrets": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/opsNotes/secrets",
              "type": "object",
              "title": "The OpsNotes schema - for K8s secrets",
              "description": "The LogicMonitor OpsNotes settings - for K8s secrets",
              "default": {},
              "examples": [
                {
                  "helmCharts": {
                    "enabled": false
                  }
                }
              ],
              "required": [
              ],
              "properties": {
                "helmCharts": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/opsNotes/helmCharts",
                  "type": "object",
                  "title": "The OpsNotes schema for helm charts releases",
                  "description": "The LogicMonitor OpsNotes settings for helm chart releases",
                  "default": {},
                  "examples": [
                    {
                      "enabled": false
                    }
                  ],
                  "required": [
                  ],
                  "properties": {
                    "enabled": {
                      "$comment": "tf:optional",
                      "$id": "#/properties/lm/properties/opsNotes/helmCharts/enabled",
                      "type": "boolean",
                      "title": "The OpsNotes settings for helm chart releases",
                      "description": "Flag to enable opsnotes for helm chart releases",
                      "default": {},
                      "examples": [
                      ],
                      "required": [
                      ]
                    }
                  }
                }
              }
            }
          }
        },
        "lmlogs": {
          "$comment": "tf:optional",
          "$id": "#/properties/lm/properties/lmlogs",
          "type": "object",
          "title": "The LMLogs schema",
          "description": "The LogicMonitor Logs collection settings.",
          "default": {},
          "examples": [
            {
              "k8sevent": {
                "enable": false
              },
              "k8spodlog": {
                "enable": false
              }
            }
          ],
          "required": [
          ],
          "properties": {
            "k8sevent": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/lmlogs/properties/k8sevent",
              "type": "object",
              "title": "The Kubernetes Events schema",
              "description": "The Kubernetes Events collection configurations.",
              "default": {},
              "examples": [
                {
                  "enable": false
                }
              ],
              "required": [
              ],
              "properties": {
                "enable": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/lmlogs/properties/k8sevent/properties/enable",
                  "type": "boolean",
                  "title": "The enable schema",
                  "description": "Once you enable the property, it starts collecting Kuberentes events.",
                  "default": false,
                  "examples": [
                    false
                  ],
                  "$comment": "ui:k8sEventEnable"
                }
              }
            },
            "k8spodlog": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/lmlogs/properties/k8spodlog",
              "type": "object",
              "title": "The k8spodlog schema.",
              "description": "Kubernetes Pod Logs collection configurations.",
              "default": {},
              "examples": [
                {
                  "enable": false
                }
              ],
              "required": [
              ],
              "properties": {
                "enable": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/lmlogs/properties/k8spodlog/properties/enable",
                  "type": "boolean",
                  "title": "The enable schema",
                  "description": "Once you enable the property, it starts Kuberentes Pod's logs collection",
                  "default": false,
                  "examples": [
                    false
                  ],
                  "$comment": "ui:k8sPodLogEnable"
                }
              }
            }
          },
          "additionalProperties": false
        },
        "resource": {
          "$comment": "tf:optional",
          "$id": "#/properties/lm/properties/resource",
          "type": "object",
          "title": "The resource schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {
              "globalDeleteAfterDuration": "P0DT0H0M0S",
              "alerting": {
                "disable": []
              }
            }
          ],
          "required": [
          ],
          "properties": {
            "globalDeleteAfterDuration": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/resource/properties/globalDeleteAfterDuration",
              "type": "string",
              "title": "The globalDeleteAfterDuration schema",
              "description": "Global scheduled delete duration to delete resources after, values must be in ISO8601 format",
              "default": "P0DT0H0M0S",
              "examples": [
                "P0DT0H0M0S"
              ],
              "pattern": "^P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+S)?)?$"
            },
            "alerting": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/resource/properties/alerting",
              "type": "object",
              "title": "The alerting schema",
              "description": "Alerting settings to apply to resource groups.\nOnly cluster scoped resources are valid here.\n If any Namespace scoped resources are set, then the namespance resources will get ignored.",
              "default": {},
              "examples": [
                {
                  "disable": []
                }
              ],
              "required": [
              ],
              "properties": {
                "disable": {
                  "$comment": "tf:optional,yamlencode",
                  "$id": "#/properties/lm/properties/resource/properties/alerting/properties/disable",
                  "type": "array",
                  "title": "The disable schema",
                  "description": "Set of resources to set disable upon resource groups.\nOnly cluster scoped resources are valid here.\nIf any Namespace scoped resources are set, then the namespance resources will get ignored.",
                  "default": [],
                  "examples": [
                    []
                  ],
                  "additionalItems": true,
                  "items": {
                    "$id": "#/properties/lm/properties/resource/properties/alerting/properties/disable/items",
                    "type": "string"
                  },
                  "uniqueItems": true
                }
              }
            }
          },
          "additionalProperties": false
        },
        "resourceGroup": {
          "$comment": "tf:optional",
          "$id": "#/properties/lm/properties/resourceGroup",
          "type": "object",
          "title": "The resourceGroup schema",
          "description": "Resource Group Settings",
          "default": {},
          "examples": [
            {
              "extraProps": {
                "cluster": [],
                "nodes": [],
                "etcd": []
              }
            }
          ],
          "required": [
          ],
          "properties": {
            "extraProps": {
              "$comment": "tf:optional",
              "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps",
              "type": "object",
              "title": "The extraProps schema",
              "description": "Extra properties to add upon resource groups, only cluster scoped resources are valid, for others resources use namespace labels",
              "default": {},
              "examples": [
                {
                  "cluster": [],
                  "nodes": [],
                  "etcd": []
                }
              ],
              "required": [
              ],
              "additionalProperties": {
                "$ref": "#/definitions/propoptsarray"
              },
              "properties": {
                "cluster": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/cluster",
                  "type": "array",
                  "title": "The cluster schema",
                  "description": "Properties to apply upon cluster tree root resource group.",
                  "default": [],
                  "examples": [
                    []
                  ],
                  "additionalItems": true,
                  "items": {
                    "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/cluster/items",
                    "$ref": "#/definitions/propopts"
                  }
                },
                "nodes": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/nodes",
                  "type": "array",
                  "title": "Properties to apply upon Nodes resource group.",
                  "description": "",
                  "default": [],
                  "examples": [
                    []
                  ],
                  "additionalItems": true,
                  "items": {
                    "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/nodes/items",
                    "$ref": "#/definitions/propopts"
                  }
                },
                "etcd": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/etcd",
                  "type": "array",
                  "title": "The etcd schema",
                  "description": "Properties to apply upon ETCD resource group.",
                  "default": [],
                  "examples": [
                    []
                  ],
                  "additionalItems": true,
                  "items": {
                    "$id": "#/properties/lm/properties/resourceGroup/properties/extraProps/properties/etcd/items",
                    "$ref": "#/definitions/propopts"
                  }
                }
              }
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "filters": {
      "$id": "#/properties/filters",
      "type": "array",
      "title": "The filters schema",
      "description": "Set of filter rules to exclude from adding into LogicMonitor.",
      "default": [],
      "examples": [
        [
          "'!(type in (\"po\", (\"deploy\"), \"ep\"))'"
        ],
        [
          "'type == \"pod\" && [app.kubernetes.io/instance] != \"lm-container\""
        ]
      ],
      "$comment": "ui:excludeRules tf:optional,yamlencode",
      "additionalItems": true,
      "items": {
        "$id": "#/properties/filters/items",
        "type": "string"
      },
      "uniqueItems": true
    },
    "overview": {
      "$id": "#/properties/overview",
      "$comment": "tf:optional",
      "type": "object",
      "title": "The Overview schema",
      "description": "Configurations for Overview Dashboard.",
      "default": {},
      "examples": [
        {
          "enable": false,
          "duration": "* * * * *"
        }
      ],
      "required": [
      ],
      "properties": {
        "enable": {
          "$comment": "tf:optional",
          "$id": "#/properties/overview/properties/enable",
          "type": "boolean",
          "title": "The enable schema",
          "description": "Once the property is enabled, argus pod annotation will be updated after every duration interval. ",
          "default": false,
          "examples": [
            false,
            true
          ]
        },
        "duration": {
          "$comment": "tf:optional",
          "$id": "#/properties/overview/properties/duration",
          "type": "string",
          "title": "The duration schema",
          "description": "Duration of argus pod annotation update in cron.",
          "examples": [
            "* * * * *"
          ]
        }
      },
      "additionalProperties": false
    },
    "selfMonitor": {
      "$id": "#/properties/selfMonitor",
      "$comment": "tf:optional",
      "type": "object",
      "title": "The selfMonitor schema",
      "description": "Configurations to expose self monitor metrics in Openmetrics format.",
      "default": {},
      "examples": [
        {
          "enable": false,
          "port": 2112
        }
      ],
      "required": [
      ],
      "properties": {
        "enable": {
          "$comment": "tf:optional",
          "$id": "#/properties/selfMonitor/properties/enable",
          "type": "boolean",
          "title": "The enable schema",
          "description": "Once the property is enabled, self monitor metrics are displayed. ",
          "default": false,
          "examples": [
            false
          ]
        },
        "port": {
          "$comment": "tf:optional",
          "$id": "#/properties/selfMonitor/properties/port",
          "type": "integer",
          "title": "The port schema",
          "description": "port number to expose self monitor \"/metrics\" endpoint",
          "default": 2112,
          "minimum": 2,
          "examples": [
            2112
          ]
        }
      },
      "additionalProperties": false
    },
    "debug": {
      "$comment": "tf:optional",
      "$id": "#/properties/debug",
      "type": "object",
      "title": "The debug schema",
      "description": "The Application debugging configurations.",
      "default": {},
      "examples": [
        {
          "profiling": {
            "enable": false
          }
        }
      ],
      "required": [
      ],
      "properties": {
        "profiling": {
          "$comment": "tf:optional",
          "$id": "#/properties/debug/properties/profiling",
          "type": "object",
          "title": "The profiling schema",
          "description": "Profile generation configurations.",
          "default": {},
          "examples": [
            {
              "enable": false
            }
          ],
          "required": [
          ],
          "properties": {
            "enable": {
              "$comment": "tf:optional",
              "$id": "#/properties/debug/properties/profiling/properties/enable",
              "type": "boolean",
              "title": "The enable schema",
              "description": "Once the property is set to true, it starts application profile generations.",
              "default": false,
              "examples": [
                false
              ]
            }
          }
        }
      },
      "additionalProperties": false
    },
    "collector": {
      "$comment": "tf:optional",
      "$id": "#/properties/collector",
      "type": "object",
      "title": "The collector schema",
      "description": "Describes the purpose of this instance.",
      "default": {},
      "examples": [
        {
          "replicas": 1,
          "version": 0,
          "size": "small",
          "useEA": false,
          "lm": {
            "groupID": 0,
            "escalationChainID": 0
          },
          "image": {
            "repository": "logicmonitor/collector",
            "tag": "latest",
            "pullPolicy": ""
          },
          "proxy": {
            "url": "",
            "user": "",
            "pass": ""
          },
          "annotations": {},
          "labels": {},
          "statefulsetSpec": {
            "template": {
              "spec": {
                "nodeSelector": {},
                "tolerations": [],
                "priorityClassName": ""
              }
            }
          }
        }
      ],
      "required": [
      ],
      "properties": {
        "replicas": {
          "$id": "#/properties/collector/properties/replicas",
          "type": "integer",
          "title": "The replicas schema",
          "description": "Describes the purpose of this instance.",
          "default": 1,
          "minimum": 1,
          "examples": [
            1
          ],
          "$comment": "ui:collectorReplicas tf:optional"
        },
        "version": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/version",
          "type": "integer",
          "format": "",
          "title": "The version schema",
          "description": "Describes the purpose of this instance.",
          "examples": [
            20101
          ]
        },
        "size": {
          "$id": "#/properties/collector/properties/size",
          "type": "string",
          "title": "The size schema",
          "description": "Describes the purpose of this instance.",
          "default": "",
          "enum": [
            "nano",
            "small",
            "medium",
            "large",
            "extra_large",
            "double_extra_large"
          ],
          "examples": [
            "small"
          ],
          "$comment": "ui:collectorSize tf:optional"
        },
        "useEA": {
          "$id": "#/properties/collector/properties/useEA",
          "type": "boolean",
          "title": "The useEA schema",
          "description": "Describes the purpose of this instance.",
          "default": false,
          "examples": [
            false
          ],
          "$comment": "ui:collectorUseEA tf:optional"
        },
        "lm": {
          "$id": "#/properties/collector/properties/lm",
          "$comment": "tf:optional",
          "type": "object",
          "title": "The lm schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {
              "groupID": 0,
              "escalationChainID": 0
            }
          ],
          "required": [
          ],
          "properties": {
            "groupID": {
              "$id": "#/properties/collector/properties/lm/properties/groupID",
              "type": "integer",
              "title": "The groupID schema",
              "description": "Describes the purpose of this instance.",
              "default": 1,
              "examples": [
                1
              ],
              "$comment": "ui:collectorGroupID tf:optional"
            },
            "escalationChainID": {
              "$id": "#/properties/collector/properties/lm/properties/escalationChainID",
              "type": "integer",
              "title": "The escalationChainID schema",
              "description": "Describes the purpose of this instance.",
              "examples": [
                1
              ],
              "$comment": "ui:collectorEscalationChainID tf:optional"
            }
          }
        },
        "image": {
          "$id": "#/properties/collector/properties/image",
          "$comment": "tf:optional",
          "type": "object",
          "title": "The image schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {
              "registry": "",
              "repository": "logicmonitor/collector",
              "tag": "latest",
              "pullPolicy": ""
            }
          ],
          "required": [
          ],
          "properties": {
            "registry": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/image/properties/registry",
              "type": "string",
              "title": "The registry schema",
              "description": "Container Image Registry",
              "default": "",
              "minLength": 0,
              "examples": [
                "382028353997.dkr.ecr.us-west-2.amazonaws.com"
              ]
            },
            "repository": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/image/properties/repository",
              "type": "string",
              "title": "The repository schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                "logicmonitor"
              ]
            },
            "name": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/image/properties/name",
              "type": "string",
              "title": "The collector image name schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                "collector"
              ]
            },
            "tag": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/image/properties/tag",
              "type": "string",
              "title": "The tag schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                "latest"
              ]
            },
            "pullPolicy": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/image/properties/pullPolicy",
              "type": "string",
              "title": "The pullPolicy schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "enum": [
                "Always",
                "IfNotPresent",
                "Never",
                ""
              ],
              "examples": [
                ""
              ]
            }
          },
          "additionalProperties": false
        },
        "proxy": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/proxy",
          "type": "object",
          "title": "The proxy schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {
              "url": "",
              "user": "",
              "pass": ""
            }
          ],
          "required": [
          ],
          "properties": {
            "url": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/proxy/properties/url",
              "type": "string",
              "title": "The url schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                ""
              ]
            },
            "user": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/proxy/properties/user",
              "type": "string",
              "title": "The user schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                ""
              ]
            },
            "pass": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/proxy/properties/pass",
              "type": "string",
              "title": "The pass schema",
              "description": "Describes the purpose of this instance.",
              "default": "",
              "examples": [
                ""
              ]
            }
          },
          "additionalProperties": false
        },
        "annotations": {
          "$comment": "tf:optional,yamlencode",
          "$id": "#/properties/collector/properties/annotations",
          "type": "object",
          "title": "The annotations schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {}
          ],
          "required": [],
          "additionalProperties": {
            "type": "string"
          }
        },
        "labels": {
          "$comment": "tf:optional,yamlencode",
          "$id": "#/properties/collector/properties/labels",
          "type": "object",
          "title": "The labels schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {}
          ],
          "additionalProperties": {
            "type": "string"
          },
          "required": []
        },
        "env": {
          "$comment": "tf:optional,yamlencode",
          "$id": "#/properties/collector/properties/env",
          "type": "object",
          "title": "The env schema",
          "description": "Environment Variables to inject in collector pod",
          "default": {},
          "examples": [
            {}
          ],
          "additionalProperties": {
            "type": "string"
          },
          "required": []
        },
        "statefulsetSpec": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/statefulsetspec",
          "description": "The collector StatefulSet specification for customizations",
          "properties": {
            "template": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/statefulsetspec/properties/template",
              "properties": {
                "spec": {
                  "$comment": "tf:optional,yamlencode",
                  "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec",
                  "properties": {
                    "containers": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers",
                      "items": {
                        "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers/items",
                        "description": "A single application container that you want to run within a pod.",
                        "properties": {
                          "name": {
                            "type": "string",
                            "minLength": 1
                          },
                          "resources": {
                            "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                            "properties": {
                              "limits": {
                                "additionalProperties": {
                                  "x-kubernetes-int-or-string": true
                                },
                                "description": "Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              },
                              "requests": {
                                "additionalProperties": {
                                  "x-kubernetes-int-or-string": true
                                },
                                "description": "Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/",
                                "type": "object"
                              }
                            },
                            "type": "object"
                          }
                        },
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "dnsConfig": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/dnsConfig",
                      "description": "PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.",
                      "properties": {
                        "nameservers": {
                          "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers/properties/nameservers",
                          "description": "A list of DNS name server IP addresses. This will be appended to the base nameservers generated from DNSPolicy. Duplicated nameservers will be removed.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        },
                        "options": {
                          "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers/properties/options",
                          "description": "A list of DNS resolver options. This will be merged with the base options generated from DNSPolicy. Duplicated entries will be removed. Resolution options given in Options will override those that appear in the base DNSPolicy.",
                          "items": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers/properties/options/items",
                            "description": "PodDNSConfigOption defines DNS resolver options of a pod.",
                            "properties": {
                              "name": {
                                "description": "Required.",
                                "type": "string"
                              },
                              "value": {
                                "type": "string"
                              }
                            },
                            "type": "object"
                          },
                          "type": "array"
                        },
                        "searches": {
                          "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/containers/properties/searches",
                          "description": "A list of DNS search domains for host-name lookup. This will be appended to the base search paths generated from DNSPolicy. Duplicated search paths will be removed.",
                          "items": {
                            "type": "string"
                          },
                          "type": "array"
                        }
                      },
                      "type": "object"
                    },
                    "dnsPolicy": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/dnsPolicy",
                      "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
                      "type": "string"
                    },
                    "hostAliases": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/hostAliases",
                      "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.",
                      "items": {
                        "description": "HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.",
                        "properties": {
                          "hostnames": {
                            "description": "Hostnames for the above IP address.",
                            "items": {
                              "type": "string"
                            },
                            "type": "array"
                          },
                          "ip": {
                            "description": "IP address of the host file entry.",
                            "type": "string"
                          }
                        },
                        "type": "object"
                      },
                      "type": "array"
                    },
                    "nodeName": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/nodename",
                      "description": "NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.",
                      "type": "string"
                    },
                    "nodeSelector": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/nodeselector",
                      "additionalProperties": {
                        "type": "string"
                      },
                      "description": "NodeSelector is a selector, which you must set to true for the pod to fit on a node. The selector must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
                      "type": "object"
                    },
                    "priority": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/priority",
                      "description": "The priority value. Various system components use the property value field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The Admission Controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
                      "format": "int32",
                      "type": "integer"
                    },
                    "priorityClassName": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/priorityclassname",
                      "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords that indicate the highest priorities with the former being the highest priority. Any other name must be defined while creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
                      "type": "string"
                    },
                    "restartPolicy": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/restartpolicy",
                      "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. Set the default value to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
                      "type": "string"
                    },
                    "schedulerName": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/schedulername",
                      "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
                      "type": "string"
                    },
                    "tolerations": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/tolerations",
                      "items": {
                        "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/tolerations/items",
                        "$ref": "#/definitions/toleration"
                      },
                      "uniqueItems": true,
                      "type": "array"
                    },
                    "volumes": {
                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes",
                      "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
                      "items": {
                        "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items",
                        "description": "Volume represents a named volume in a pod that may be accessed by any container in the pod.",
                        "properties": {
                          "awsElasticBlockStore": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/awselasticblockstore",
                            "description": "Represents a Persistent Disk resource in AWS.\n\nYou must exit the AWS EBS disk before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.",
                            "properties": {
                              "fsType": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/awselasticblockstore/properties/fstype",
                                "description": "Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                                "type": "string"
                              },
                              "partition": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/awselasticblockstore/properties/partition",
                                "description": "The partition in the volume that you want to mount. If omitted, by default it mounts by volume name. Examples: For volume /dev/sda1, you specify the partition as \"1\". Similarly, the volume partition for /dev/sda is \"0\" (or you can leave the property empty).",
                                "format": "int32",
                                "type": "integer"
                              },
                              "readOnly": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/awselasticblockstore/properties/readonly",
                                "description": "Specify \"true\" to force and set the ReadOnly property in VolumeMounts to \"true\". If omitted, the default is set to \"false\". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                                "type": "boolean"
                              },
                              "volumeID": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/awselasticblockstore/properties/volumeid",
                                "description": "Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore",
                                "type": "string"
                              }
                            },
                            "required": [
                              "volumeID"
                            ],
                            "type": "object"
                          },
                          "azureDisk": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk",
                            "description": "AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.",
                            "properties": {
                              "cachingMode": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/cachingmode",
                                "description": "Host Caching mode: None, Read Only, Read Write.",
                                "type": "string"
                              },
                              "diskName": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/diskname",
                                "description": "The name of the data disk in the blob storage.",
                                "type": "string"
                              },
                              "diskURI": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/diskuri",
                                "description": "The URI of the data disk in the blob storage",
                                "type": "string"
                              },
                              "fsType": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/fstype",
                                "description": "Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.",
                                "type": "string"
                              },
                              "kind": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/kind",
                                "description": "Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: Azure managed data disk (only in managed availability set). defaults to shared",
                                "type": "string"
                              },
                              "readOnly": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/azuredisk/properties/readonly",
                                "description": "By default, the propertu is set to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.",
                                "type": "boolean"
                              }
                            },
                            "required": [
                              "diskName",
                              "diskURI"
                            ],
                            "type": "object"
                          },
                          "configMap": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/configmap",
                            "description": "Adapts a ConfigMap into a volume.\n\nThe contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.",
                            "properties": {
                              "defaultMode": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/defaultmode",
                                "description": "Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                "format": "int32",
                                "type": "integer"
                              },
                              "items": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/items",
                                "description": "If not specified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified and is not present in the ConfigMap, the volume setup will display an error unless it is marked optional. Paths must be relative and must not contain the '..' path or start with '..'.",
                                "items": {
                                  "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/configmap/items/items",
                                  "description": "Maps a string key to a path within a volume.",
                                  "properties": {
                                    "key": {
                                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/configmap/items/items/properties/key",
                                      "description": "The key to project.",
                                      "type": "string"
                                    },
                                    "mode": {
                                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/configmap/items/items/properties/mode",
                                      "description": "Optional, mode bits to use on this file, must be a value between 0 and 0777. If not specified, the defalut volume for mode will be used. This could create conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.",
                                      "format": "int32",
                                      "type": "integer"
                                    },
                                    "path": {
                                      "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/configmap/items/items/properties/path",
                                      "description": "The relative path of the file to map the key to. This may not be an absolute path. May not contain the path element '..'. May not start with the string '..'.",
                                      "type": "string"
                                    }
                                  },
                                  "required": [
                                    "key",
                                    "path"
                                  ],
                                  "type": "object"
                                },
                                "type": "array"
                              },
                              "name": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/name",
                                "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                                "type": "string"
                              },
                              "optional": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/optional",
                                "description": "Specify whether the ConfigMap or it's keys must be defined",
                                "type": "boolean"
                              }
                            },
                            "type": "object"
                          },
                          "emptyDir": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/emptydir",
                            "description": "Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.",
                            "properties": {
                              "medium": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/emptydir/properties/medium",
                                "description": "Specifies the type of storage medium should back this directory. The default is \"\" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir",
                                "type": "string"
                              },
                              "sizeLimit": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/emptydir/properties/sizelimit",
                                "description": "Total amount of local storage required for this EmptyDir volume. The size limit is also applicable for memory medium. The maximum usage on memory medium EmptyDir would be the minimum value between the SizeLimit specified here and the sum of memory limits of all containers in a pod. The default is nil which means that the limit is undefined. More info: https://kubernetes.io/docs/user-guide/volumes#emptydir",
                                "x-kubernetes-int-or-string": true
                              }
                            },
                            "type": "object"
                          },
                          "hostPath": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/hostpath",
                            "description": "Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.",
                            "properties": {
                              "path": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/hostpath/properties/path",
                                "description": "Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                                "type": "string"
                              },
                              "type": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/hostpath/properties/type",
                                "description": "Type for HostPath Volume, by default is set to \"\" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath",
                                "type": "string"
                              }
                            },
                            "required": [
                              "path"
                            ],
                            "type": "object"
                          },
                          "name": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/name",
                            "description": "Volume's name. Must be a DNS_LABEL and unique within the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
                            "type": "string"
                          },
                          "persistentVolumeClaim": {
                            "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/persistentvolumeclaim",
                            "description": "PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).",
                            "properties": {
                              "claimName": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/persistentvolumeclaim/properties/claimname",
                                "description": "ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims",
                                "type": "string"
                              },
                              "readOnly": {
                                "$id": "#/properties/collector/properties/statefulsetspec/properties/template/properties/spec/properties/volumes/items/properties/persistentvolumeclaim/properties/readonly",
                                "description": "Will force the ReadOnly setting in VolumeMounts. Default false.",
                                "type": "boolean"
                              }
                            },
                            "required": [
                              "claimName"
                            ],
                            "type": "object"
                          }
                        },
                        "required": [
                          "name"
                        ],
                        "type": "object"
                      },
                      "type": "array"
                    }
                  },
                  "type": "object"
                }
              },
              "type": "object"
            }
          },
          "type": "object",
          "x-kubernetes-preserve-unknown-fields": true
        },
        "probe": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/probe",
          "description": "The container probe configuration schema.",
          "type": "object",
          "properties": {
            "enabled": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/probe/properties/enabled",
              "type": "boolean",
              "default": true,
              "description": "Enables container probes."
            },
            "startup": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/probe/properties/startup",
              "properties": {
                "failureThreshold": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/startup/properties/failureThreshold",
                  "type": "integer",
                  "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the Argus startup.",
                  "default": 20,
                  "minimum": 1
                },
                "periodSeconds": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/startup/properties/periodSeconds",
                  "type": "integer",
                  "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                  "default": 30,
                  "minimum": 1
                }
              },
              "additionalProperties": false
            },
            "liveness": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/probe/properties/liveness",
              "properties": {
                "failureThreshold": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/liveness/properties/failureThreshold",
                  "type": "integer",
                  "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the argus startup",
                  "default": 30,
                  "minimum": 1
                },
                "periodSeconds": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/liveness/properties/periodSeconds",
                  "type": "integer",
                  "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                  "default": 10,
                  "minimum": 1
                }
              },
              "additionalProperties": false
            },
            "readiness": {
              "$comment": "tf:optional",
              "$id": "#/properties/collector/properties/probe/properties/readiness",
              "properties": {
                "failureThreshold": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/readiness/properties/failureThreshold",
                  "type": "integer",
                  "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the Argus startup",
                  "default": 30,
                  "minimum": 1
                },
                "periodSeconds": {
                  "$comment": "tf:optional",
                  "$id": "#/properties/collector/properties/probe/properties/readiness/properties/periodSeconds",
                  "type": "integer",
                  "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
                  "default": 10,
                  "minimum": 1
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        "disableLightweightCollector": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/enableLightweightCollector",
          "type": "boolean",
          "default": false
        },
        "allowMultipleCollectorsOnNode": {
          "$comment": "tf:optional",
          "$id": "#/properties/collector/properties/multipleCollectorsOnNode",
          "type": "boolean",
          "default": true
        },
        "collectorConf": {
          "$id": "#/properties/collector/properties/collectorConf",
          "$comment": "tf:optional",
          "type": "object",
          "properties": {
            "agentConf": {
              "$comment": "tf:optional,yamlencode",
              "type": "array",
              "items": {
                "$ref": "#/definitions/collectorConfKeyVal"
              },
              "uniqueItems": true
            }
          },
          "additionalProperties": false
        },
        "securityContext": {
          "$id": "#/properties/collector/properties/securityContext",
          "$ref": "#/definitions/io.k8s.api.core.v1.SecurityContext"
        },
        "podSecurityContext": {
          "$id": "#/properties/collector/properties/podSecurityContext",
          "$ref": "#/definitions/io.k8s.api.core.v1.PodSecurityContext"
        },
        "affinity": {
          "$id": "#/properties/collector/properties/affinity",
          "$ref": "#/definitions/io.k8s.api.core.v1.Affinity"
        }
      },
      "additionalProperties": false
    },
    "global": {
      "$id": "#/properties/global",
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "accessID": {
          "$id": "#/properties/global/properties/accessID",
          "type": "string",
          "title": "Logicmonitor API Token accessID",
          "description": "The LogicMonitor API key ID.\nNOTE: Ensure to add surrounding double quotes to avoid special character parsing errors.",
          "default": "",
          "examples": [
            ""
          ],
          "$comment": "ui:accessId tf:optional"
        },
        "accessKey": {
          "$id": "#/properties/global/properties/accessKey",
          "type": "string",
          "title": "Logicmonitor API Token accessKey",
          "description": "The LogicMonitor API key.\nNOTE: Ensure to add surrounding double quotes to avoid special character parsing errors.",
          "default": "",
          "examples": [
            ""
          ],
          "$comment": "ui:accessKey tf:optional"
        },
        "account": {
          "$id": "#/properties/global/properties/account",
          "type": "string",
          "title": "Logicmonitor account name",
          "description": "The LogicMonitor account name.nValue should be trimmed from URL \"___.logicmonitor.com\"\nexample: lmqauat.logicmonitor.com then \"lmqauat\" must be a valid value.",
          "default": "",
          "examples": [
            "lmqauat"
          ],
          "$comment": "ui:account tf:optional"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "examples": [
            [
              {
                "name": "imagepullsecret1"
              }
            ]
          ],
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
          },
          "type": "array"
        },
        "image": {
          "$comment": "tf:optional",
          "$id": "#/properties/global/properties/image",
          "type": "object",
          "title": "The image schema",
          "description": "Describes the purpose of this instance.",
          "default": {},
          "examples": [
            {
              "pullPolicy": "Always"
            }
          ],
          "required": [],
          "properties": {
            "registry": {
              "$comment": "tf:optional",
              "$id": "#/properties/global/properties/image/properties/registry",
              "type": "string",
              "title": "The registry schema",
              "description": "Container Image Registry.",
              "default": "",
              "minLength": 0,
              "examples": [
                "382028353997.dkr.ecr.us-west-2.amazonaws.com"
              ]
            },
            "repository": {
              "$comment": "tf:optional",
              "$id": "#/properties/global/properties/image/properties/repository",
              "type": "string",
              "title": "The repository schema",
              "description": "Container Image Repository.",
              "default": "",
              "minLength": 0,
              "examples": [
                "logicmonitor"
              ]
            },
            "pullPolicy": {
              "$comment": "tf:optional",
              "$id": "#/properties/global/properties/image/properties/pullpolicy",
              "type": "string",
              "title": "pullPolicy",
              "description": "Overrides the image tag whose default is the chart appVersion.",
              "default": "Always",
              "enum": [
                "Always",
                "IfNotPresent",
                "Never",
                ""
              ],
              "examples": [
                "Always"
              ]
            }
          }
        },
        "proxy": {
          "$id": "#/properties/proxy",
          "$comment": "tf:optional",
          "type": "object",
          "title": "proxy",
          "description": "Http/s proxy",
          "default": {},
          "examples": [
            {
              "url": "",
              "user": "",
              "pass": ""
            }
          ],
          "required": [
          ],
          "properties": {
            "url": {
              "$id": "#/properties/proxy/properties/url",
              "type": "string",
              "title": "url",
              "description": "Proxy service endpoint.",
              "default": "",
              "examples": [
                ""
              ],
              "$comment": "ui:proxyURL tf:optional"
            },
            "user": {
              "$id": "#/properties/proxy/properties/user",
              "type": "string",
              "title": "The user schema",
              "description": "User for Proxy service.",
              "default": "",
              "examples": [
                ""
              ],
              "$comment": "ui:proxyUser tf:optional"
            },
            "pass": {
              "$id": "#/properties/proxy/properties/pass",
              "type": "string",
              "title": "pass",
              "description": "Password for the Proxy service.",
              "default": "",
              "examples": [
                ""
              ],
              "$comment": "ui:proxyPass tf:optional"
            }
          }
        },
        "collectorsetServiceNameSuffix": {
          "$comment": "tf:optional",
          "type": "string",
          "default": "",
          "description": "Suffix to be added to .Release.name to generate Collectorset controller service URL.\nKeep it empty while installing this chart individually, umbrella chart uses this to generate unique name across."
        },
        "userDefinedSecret": {
          "$id": "#/properties/global/properties/userDefinedSecret",
          "$comment": "tf:optional",
          "type": "string",
          "default": "",
          "description": "User can provide LM credentials in a Secret instead of plain text. The secret should contain 'accessID', 'accessKey', 'account' along with optional params e.g. 'etcdDiscoveryToken', proxy credentials"
        }
      }
    },
    "nameOverride": {
      "$id": "#/properties/nameOverride",
      "$comment": "tf:optional",
      "type": "string",
      "title": "The nameOverride schema",
      "description": "Describes the purpose of this instance.",
      "default": "",
      "examples": [
        ""
      ]
    },
    "fullnameOverride": {
      "$comment": "tf:optional",
      "$id": "#/properties/fullnameOverride",
      "type": "string",
      "title": "The fullnameOverride schema",
      "description": "Describes the purpose of this instance.",
      "default": "",
      "examples": [
        ""
      ]
    },
    "rbac": {
      "$comment": "tf:optional",
      "$id": "#/properties/rbac",
      "type": "object",
      "title": "The rbac schema",
      "description": "Describes the purpose of this instance.",
      "default": {},
      "examples": [
        {
          "create": true
        }
      ],
      "required": [
      ],
      "properties": {
        "create": {
          "$id": "#/properties/rbac/properties/create",
          "type": "boolean",
          "title": "The create schema",
          "description": "Describes the purpose of this instance.",
          "default": false,
          "examples": [
            true
          ],
          "$comment": "ui:enableRBAC tf:optional"
        }
      },
      "additionalProperties": false
    },
    "serviceAccount": {
      "$comment": "tf:optional",
      "$id": "#/properties/serviceAccount",
      "type": "object",
      "title": "The serviceAccount schema",
      "description": "Describes the purpose of this instance.",
      "default": {},
      "examples": [
        {
          "create": true
        }
      ],
      "required": [
      ],
      "properties": {
        "create": {
          "$comment": "tf:optional",
          "$id": "#/properties/serviceAccount/properties/create",
          "type": "boolean",
          "title": "The create schema",
          "description": "Describes the purpose of this instance.",
          "default": false,
          "examples": [
            true
          ]
        }
      },
      "additionalProperties": false
    },
    "securityContext": {
      "$id": "#/properties/securityContext",
      "$ref": "#/definitions/io.k8s.api.core.v1.SecurityContext"
    },
    "podSecurityContext": {
      "$id": "#/properties/podSecurityContext",
      "$ref": "#/definitions/io.k8s.api.core.v1.PodSecurityContext"
    },
    "imagePullSecrets": {
      "$comment": "tf:optional,yamlencode",
      "$id": "#/properties/imagePullSecrets",
      "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
      "items": {
        "$ref": "#/definitions/io.k8s.api.core.v1.LocalObjectReference"
      },
      "type": "array",
      "x-kubernetes-patch-merge-key": "name",
      "x-kubernetes-patch-strategy": "merge"
    },
    "probe": {
      "$id": "#/properties/probe",
      "$comment": "tf:optional",
      "description": "The container probe configuration schema",
      "type": "object",
      "properties": {
        "enabled": {
          "$comment": "tf:optional",
          "$id": "#/properties/probe/properties/enabled",
          "type": "boolean",
          "default": true,
          "description": "Enables container probes."
        },
        "startup": {
          "$id": "#/properties/probe/properties/startup",
          "$comment": "tf:optional",
          "properties": {
            "failureThreshold": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/startup/properties/failureThreshold",
              "type": "integer",
              "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the Argus startup.",
              "default": 30,
              "minimum": 1
            },
            "periodSeconds": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/startup/properties/periodSeconds",
              "type": "integer",
              "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
              "default": 10,
              "minimum": 1
            }
          },
          "additionalProperties": false
        },
        "liveness": {
          "$comment": "tf:optional",
          "$id": "#/properties/probe/properties/liveness",
          "properties": {
            "failureThreshold": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/liveness/properties/failureThreshold",
              "type": "integer",
              "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the Argus startup",
              "default": 3,
              "minimum": 1
            },
            "periodSeconds": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/liveness/properties/periodSeconds",
              "type": "integer",
              "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
              "default": 10,
              "minimum": 1
            }
          },
          "additionalProperties": false
        },
        "readiness": {
          "$comment": "tf:optional",
          "$id": "#/properties/probe/properties/readiness",
          "properties": {
            "failureThreshold": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/readiness/properties/failureThreshold",
              "type": "integer",
              "description": "The failureThreshold is maximum count before marking container start failed, typically collector installation time affects the Argus startup",
              "default": 3,
              "minimum": 1
            },
            "periodSeconds": {
              "$comment": "tf:optional",
              "$id": "#/properties/probe/properties/readiness/properties/periodSeconds",
              "type": "integer",
              "description": "How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.",
              "default": 10,
              "minimum": 1
            }
          },
          "additionalProperties": false
        }
      },
      "additionalProperties": false
    },
    "lmutil": {
      "$id": "#/properties/lmutil",
      "additionalProperties": true
    }
  },
  "additionalProperties": false,
  "definitions": {
    "collectorConfKeyVal": {
      "if": {
        "properties": {
          "discrete": {
            "type": "boolean",
            "enum": [
              false
            ]
          }
        }
      },
      "then": {
        "additionalProperties": false,
        "properties": {
          "discrete": {
            "type": "boolean"
          },
          "value": {
            "type": [
              "object",
              "number",
              "null",
              "integer",
              "array",
              "boolean",
              "string"
            ]
          },
          "key": {
            "type": "string",
            "minLength": 1
          },
          "dontOverride": {
            "type": "boolean"
          },
          "coalesceFormat": {
            "enum": [
              "",
              "csv",
              "json",
              "pipe"
            ],
            "default": ""
          }
        }
      },
      "else": {
        "additionalProperties": false,
        "properties": {
          "discrete": {
            "type": "boolean"
          },
          "values": {
            "type": "array",
            "items": {
              "type": [
                "object",
                "number",
                "null",
                "integer",
                "array",
                "boolean",
                "string"
              ]
            }
          },
          "key": {
            "type": "string",
            "minLength": 1
          },
          "dontOverride": {
            "type": "boolean"
          },
          "coalesceFormat": {
            "enum": [
              "",
              "csv",
              "json",
              "pipe"
            ],
            "default": ""
          }
        }
      }
    },
    "toleration": {
      "$comment": "",
      "oneOf": [
        {
          "properties": {
            "effect": {
              "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
              "type": "string"
            },
            "key": {
              "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
              "type": "string"
            },
            "operator": {
              "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
              "type": "string",
              "enum": [
                "Exists"
              ]
            },
            "tolerationSeconds": {
              "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
              "format": "int64",
              "type": "integer"
            },
            "value": {
              "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
              "type": "string",
              "maxLength": 0
            }
          },
          "type": "object"
        },
        {
          "properties": {
            "effect": {
              "description": "Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.",
              "type": "string"
            },
            "key": {
              "description": "Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.",
              "type": "string"
            },
            "operator": {
              "description": "Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.",
              "type": "string",
              "enum": [
                "Equal"
              ]
            },
            "tolerationSeconds": {
              "description": "TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.",
              "format": "int64",
              "type": "integer"
            },
            "value": {
              "description": "Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.",
              "type": "string",
              "minLength": 1
            }
          },
          "type": "object"
        }
      ]
    },
    "propopts": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1
        },
        "value": {
          "type": "string",
          "minLength": 0
        },
        "override": {
          "type": "boolean",
          "default": true
        }
      }
    },
    "propoptsarray": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/propopts"
      },
      "uniqueItems": true
    },
    "io.k8s.apimachinery.pkg.api.resource.Quantity": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "number"
        }
      ]
    },
    "io.k8s.api.core.v1.LocalObjectReference": {
      "description": "LocalObjectReference contains information to locate the referenced object inside the same namespace.",
      "properties": {
        "name": {
          "description": "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names",
          "type": "string"
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.PodSecurityContext": {
      "description": "PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.",
      "properties": {
        "fsGroup": {
          "description": "A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:\n\n1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----\n\nIf unset, the Kubelet will not modify the ownership and permissions of any volume.",
          "format": "int64",
          "type": "integer"
        },
        "fsGroupChangePolicy": {
          "description": "fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are \"OnRootMismatch\" and \"Always\". If not specified defaults to \"Always\".",
          "type": "string"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
          "format": "int64",
          "type": "integer"
        },
        "runAsNonRoot": {
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "boolean"
        },
        "runAsUser": {
          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.",
          "format": "int64",
          "type": "integer"
        },
        "seLinuxOptions": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SELinuxOptions",
          "description": "The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container."
        },
        "supplementalGroups": {
          "description": "A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.",
          "items": {
            "format": "int64",
            "type": "integer"
          },
          "type": "array"
        },
        "sysctls": {
          "description": "Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.Sysctl"
          },
          "type": "array"
        },
        "windowsOptions": {
          "$ref": "#/definitions/io.k8s.api.core.v1.WindowsSecurityContextOptions",
          "description": "The Windows specific settings applied to all containers. If unspecified, the options within a container's SecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence."
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.SELinuxOptions": {
      "description": "SELinuxOptions are the labels to be applied to the container",
      "properties": {
        "level": {
          "description": "Level is SELinux level label that applies to the container.",
          "type": "string"
        },
        "role": {
          "description": "Role is a SELinux role label that applies to the container.",
          "type": "string"
        },
        "type": {
          "description": "Type is a SELinux type label that applies to the container.",
          "type": "string"
        },
        "user": {
          "description": "User is a SELinux user label that applies to the container.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.Sysctl": {
      "description": "Sysctl defines a kernel parameter to be set",
      "properties": {
        "name": {
          "description": "Name of a property to set",
          "type": "string"
        },
        "value": {
          "description": "Value of a property to set",
          "type": "string"
        }
      },
      "required": [
        "name",
        "value"
      ],
      "type": "object"
    },
    "io.k8s.api.core.v1.WindowsSecurityContextOptions": {
      "description": "WindowsSecurityContextOptions contain Windows-specific options and credentials.",
      "properties": {
        "gmsaCredentialSpec": {
          "description": "GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName field.",
          "type": "string"
        },
        "gmsaCredentialSpecName": {
          "description": "GMSACredentialSpecName is the name of the GMSA credential spec to use.",
          "type": "string"
        },
        "runAsUserName": {
          "description": "The UserName in Windows to run the entrypoint of the container process. Defaults to the user specified in image metadata if unspecified. May also be set in PodSecurityContext. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.Capabilities": {
      "description": "Adds and removes POSIX capabilities from running containers.",
      "properties": {
        "add": {
          "description": "Added capabilities",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "drop": {
          "description": "Removed capabilities",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.SecurityContext": {
      "description": "SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.",
      "properties": {
        "allowPrivilegeEscalation": {
          "description": "AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN",
          "type": "boolean"
        },
        "capabilities": {
          "$ref": "#/definitions/io.k8s.api.core.v1.Capabilities",
          "description": "The capabilities to add/drop when running containers. Defaults to the default set of capabilities granted by the container runtime."
        },
        "privileged": {
          "description": "Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.",
          "type": "boolean"
        },
        "procMount": {
          "description": "procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.",
          "type": "string"
        },
        "readOnlyRootFilesystem": {
          "description": "Whether this container has a read-only root filesystem. Default is false.",
          "type": "boolean"
        },
        "runAsGroup": {
          "description": "The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "format": "int64",
          "type": "integer"
        },
        "runAsNonRoot": {
          "description": "Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "type": "boolean"
        },
        "runAsUser": {
          "description": "The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.",
          "format": "int64",
          "type": "integer"
        },
        "seLinuxOptions": {
          "$ref": "#/definitions/io.k8s.api.core.v1.SELinuxOptions",
          "description": "The SELinux context to be applied to the container. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence."
        },
        "windowsOptions": {
          "$ref": "#/definitions/io.k8s.api.core.v1.WindowsSecurityContextOptions",
          "description": "The Windows specific settings applied to all containers. If unspecified, the options from the PodSecurityContext will be used. If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence."
        }
      },
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement": {
      "required": [
        "key", 
        "operator"
      ],
      "description": "A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      "properties": {
        "operator": {
          "description": "operator represents a key's relationship to a set of values. Valid operators ard In, NotIn, Exists and DoesNotExist.",
          "type": "string"
        },
        "values": {
          "items": {
            "type": "string"
          },
          "description": "values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.",
          "type": "array"
        }, 
        "key": {
          "description": "key is the label key that the selector applies to.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector": {
      "description": "A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.", 
      "properties": {
        "matchLabels": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.",
          "type": "object"
        },
        "matchExpressions": {
          "items": {
            "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
          },
          "description": "matchExpressions is a list of label selector requirements. The requirements are ANDed.",
          "type": "array"
        }
      },
      "type": "object"
    },
    "io.k8s.kubernetes.pkg.api.v1.WeightedPodAffinityTerm": {
      "required": [
        "weight", 
        "podAffinityTerm"
      ],
      "description": "The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)",
      "properties": {
        "podAffinityTerm": {
          "description": "Required. A pod affinity term, associated with the corresponding weight.",
          "$ref": "#/definitions/io.k8s.kubernetes.pkg.api.v1.PodAffinityTerm"
        },
        "weight": {
          "type": "integer",
          "description": "weight associated with matching the corresponding podAffinityTerm, in the range 1-100.",
          "format": "int32"
        }
      },
      "type": "object"
    },
    "io.k8s.kubernetes.pkg.api.v1.PodAffinityTerm": {
      "required": [
        "topologyKey"
      ],
      "description": "Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> tches that of any node on which a pod of the set of pods is running", 
      "properties": {
        "labelSelector": {
          "description": "A label query over a set of resources, in this case pods.", 
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }, 
        "namespaces": {
          "items": {
            "type": "string"
          },
          "description": "namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \"this pod's namespace\"",
          "type": "array"
        }, 
        "topologyKey": {
          "type": "string",
          "description": "This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. For PreferredDuringScheduling pod anti-affinity, empty topologyKey is interpreted as \"all topologies\" (\"all topologies\" here means all the topologyKeys indicated by scheduler command-line argument --failure-domains); for affinity and for RequiredDuringScheduling pod anti-affinity, empty topologyKey is not allowed."
        },
        "namespaceSelector": {
          "description": "A label query over a set of resources, in this case pods.", 
          "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.NodeSelectorRequirement": {
      "description": "A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.",
      "properties": {
        "key": {
          "description": "The label key that the selector applies to.",
          "type": "string"
        },
        "operator": {
          "description": "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.",
          "type": "string"
        },
        "values": {
          "description": "An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "key",
        "operator"
      ],
      "type": "object"
    },
    "io.k8s.api.core.v1.NodeSelectorTerm": {
      "description": "A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.",
      "properties": {
        "matchExpressions": {
          "description": "A list of node selector requirements by node's labels.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorRequirement"
          },
          "type": "array"
        },
        "matchFields": {
          "description": "A list of node selector requirements by node's fields.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorRequirement"
          },
          "type": "array"
        }
      },
      "type": "object",
      "x-kubernetes-map-type": "atomic"
    },
    "io.k8s.api.core.v1.PreferredSchedulingTerm": {
      "description": "An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).",
      "properties": {
        "preference": {
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorTerm",
          "description": "A node selector term, associated with the corresponding weight."
        },
        "weight": {
          "description": "Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.",
          "format": "int32",
          "type": "integer"
        }
      },
      "required": [
        "weight",
        "preference"
      ],
      "type": "object"
    },
    "io.k8s.api.core.v1.NodeSelector": {
      "description": "A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.",
      "properties": {
        "nodeSelectorTerms": {
          "description": "Required. A list of node selector terms. The terms are ORed.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelectorTerm"
          },
          "type": "array"
        }
      },
      "required": [
        "nodeSelectorTerms"
      ],
      "type": "object"
    },
    "io.k8s.api.core.v1.NodeAffinity": {
      "description": "Node affinity is a group of node affinity scheduling rules.",
      "properties": {
        "preferredDuringSchedulingIgnoredDuringExecution": {
          "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.",
          "items": {
            "$ref": "#/definitions/io.k8s.api.core.v1.PreferredSchedulingTerm"
          },
          "type": "array"
        },
        "requiredDuringSchedulingIgnoredDuringExecution": {
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeSelector",
          "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node."
        }
      },
      "type": "object"
    },
    "io.k8s.api.core.v1.Affinity": {
      "properties": {
        "nodeAffinity": {
          "$ref": "#/definitions/io.k8s.api.core.v1.NodeAffinity",
          "description": "Describes node affinity scheduling rules for the pod."
        },
        "podAffinity": {
          "description": "Pod affinity is a group of inter pod affinity scheduling rules.",
          "properties": {
            "requiredDuringSchedulingIgnoredDuringExecution": {
              "description": "If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.",
              "items": {
                "$ref": "#/definitions/io.k8s.kubernetes.pkg.api.v1.PodAffinityTerm"
              },
              "type": "array"
            },
            "preferredDuringSchedulingIgnoredDuringExecution": {
              "description": "The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.",
              "items": {
                "$ref": "#/definitions/io.k8s.kubernetes.pkg.api.v1.WeightedPodAffinityTerm"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "podAntiAffinity": {
          "description": "Pod anti affinity is a group of inter pod anti affinity scheduling rules.",
          "properties": {
            "requiredDuringSchedulingIgnoredDuringExecution": {
              "items": {
                "$ref": "#/definitions/io.k8s.kubernetes.pkg.api.v1.PodAffinityTerm"
              },
              "type": "array",
              "description": "If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:\"requiredDuringSchedulingRequiredDuringExecution,omitempty\"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied."
            }, 
            "preferredDuringSchedulingIgnoredDuringExecution": {
              "items": {
                "$ref": "#/definitions/io.k8s.kubernetes.pkg.api.v1.WeightedPodAffinityTerm"
              },
              "type": "array",
              "description": "The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \"weight\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred."
            }
          },
          "type": "object"
        }
      },
      "type": "object"
    }
  }
}